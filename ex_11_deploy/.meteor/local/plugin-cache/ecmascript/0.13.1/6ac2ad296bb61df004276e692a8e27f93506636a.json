{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/gbox3d/Desktop/work/myproject/meteor_study/ex_11/packages/ejson/ejson.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx",["flow",{}],"nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}]],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"packages/ejson/ejson.js","filename":"/Users/gbox3d/Desktop/work/myproject/meteor_study/ex_11/packages/ejson/ejson.js","passPerPreset":false,"envName":"development","cwd":"/Users/gbox3d/Desktop/work/myproject/meteor_study/ex_11","root":"/Users/gbox3d/Desktop/work/myproject/meteor_study/ex_11","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.7.4","helpers":true,"useESModules":false,"corejs":false}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$3","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$4","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":{},"_verified":{},"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"TSModuleBlock":{"enter":[null]}},"options":{}},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]}},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/gbox3d/Desktop/work/myproject/meteor_study/ex_11/packages/ejson/ejson.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/ejson/ejson.js"}},"code":"var _typeof;\n\nmodule.link(\"@babel/runtime/helpers/typeof\", {\n  default: function (v) {\n    _typeof = v;\n  }\n}, 0);\nmodule.export({\n  EJSON: function () {\n    return EJSON;\n  }\n});\n\n/**\n * @namespace\n * @summary Namespace for EJSON functions\n */\nvar EJSON = {}; // Custom type interface definition\n\n/**\n * @class CustomType\n * @instanceName customType\n * @memberOf EJSON\n * @summary The interface that a class must satisfy to be able to become an\n * EJSON custom type via EJSON.addType.\n */\n\n/**\n * @function typeName\n * @memberOf EJSON.CustomType\n * @summary Return the tag used to identify this type.  This must match the\n *          tag used to register this type with\n *          [`EJSON.addType`](#ejson_add_type).\n * @locus Anywhere\n * @instance\n */\n\n/**\n * @function toJSONValue\n * @memberOf EJSON.CustomType\n * @summary Serialize this instance into a JSON-compatible value.\n * @locus Anywhere\n * @instance\n */\n\n/**\n * @function clone\n * @memberOf EJSON.CustomType\n * @summary Return a value `r` such that `this.equals(r)` is true, and\n *          modifications to `r` do not affect `this` and vice versa.\n * @locus Anywhere\n * @instance\n */\n\n/**\n * @function equals\n * @memberOf EJSON.CustomType\n * @summary Return `true` if `other` has a value equal to `this`; `false`\n *          otherwise.\n * @locus Anywhere\n * @param {Object} other Another object to compare this to.\n * @instance\n */\n\nvar customTypes = {};\n\nvar hasOwn = function (obj, prop) {\n  return {}.hasOwnProperty.call(obj, prop);\n};\n\nvar isArguments = function (obj) {\n  return obj != null && hasOwn(obj, 'callee');\n};\n\nvar isInfOrNan = function (obj) {\n  return Number.isNaN(obj) || obj === Infinity || obj === -Infinity;\n}; // Add a custom type, using a method of your choice to get to and\n// from a basic JSON-able representation.  The factory argument\n// is a function of JSON-able --> your object\n// The type you add must have:\n// - A toJSONValue() method, so that Meteor can serialize it\n// - a typeName() method, to show how to look it up in our type table.\n// It is okay if these methods are monkey-patched on.\n// EJSON.clone will use toJSONValue and the given factory to produce\n// a clone, but you may specify a method clone() that will be\n// used instead.\n// Similarly, EJSON.equals will use toJSONValue to make comparisons,\n// but you may provide a method equals() instead.\n\n/**\n * @summary Add a custom datatype to EJSON.\n * @locus Anywhere\n * @param {String} name A tag for your custom type; must be unique among\n *                      custom data types defined in your project, and must\n *                      match the result of your type's `typeName` method.\n * @param {Function} factory A function that deserializes a JSON-compatible\n *                           value into an instance of your type.  This should\n *                           match the serialization performed by your\n *                           type's `toJSONValue` method.\n */\n\n\nEJSON.addType = function (name, factory) {\n  if (hasOwn(customTypes, name)) {\n    throw new Error(\"Type \" + name + \" already present\");\n  }\n\n  customTypes[name] = factory;\n};\n\nvar builtinConverters = [{\n  // Date\n  matchJSONValue: function (obj) {\n    return hasOwn(obj, '$date') && Object.keys(obj).length === 1;\n  },\n  matchObject: function (obj) {\n    return obj instanceof Date;\n  },\n  toJSONValue: function (obj) {\n    return {\n      $date: obj.getTime()\n    };\n  },\n  fromJSONValue: function (obj) {\n    return new Date(obj.$date);\n  }\n}, {\n  // RegExp\n  matchJSONValue: function (obj) {\n    return hasOwn(obj, '$regexp') && hasOwn(obj, '$flags') && Object.keys(obj).length === 2;\n  },\n  matchObject: function (obj) {\n    return obj instanceof RegExp;\n  },\n  toJSONValue: function (regexp) {\n    return {\n      $regexp: regexp.source,\n      $flags: regexp.flags\n    };\n  },\n  fromJSONValue: function (obj) {\n    // Replaces duplicate / invalid flags.\n    return new RegExp(obj.$regexp, obj.$flags // Cut off flags at 50 chars to avoid abusing RegExp for DOS.\n    .slice(0, 50).replace(/[^gimuy]/g, '').replace(/(.)(?=.*\\1)/g, ''));\n  }\n}, {\n  // NaN, Inf, -Inf. (These are the only objects with typeof !== 'object'\n  // which we match.)\n  matchJSONValue: function (obj) {\n    return hasOwn(obj, '$InfNaN') && Object.keys(obj).length === 1;\n  },\n  matchObject: isInfOrNan,\n  toJSONValue: function (obj) {\n    var sign;\n\n    if (Number.isNaN(obj)) {\n      sign = 0;\n    } else if (obj === Infinity) {\n      sign = 1;\n    } else {\n      sign = -1;\n    }\n\n    return {\n      $InfNaN: sign\n    };\n  },\n  fromJSONValue: function (obj) {\n    return obj.$InfNaN / 0;\n  }\n}, {\n  // Binary\n  matchJSONValue: function (obj) {\n    return hasOwn(obj, '$binary') && Object.keys(obj).length === 1;\n  },\n  matchObject: function (obj) {\n    return typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array || obj && hasOwn(obj, '$Uint8ArrayPolyfill');\n  },\n  toJSONValue: function (obj) {\n    return {\n      $binary: Base64.encode(obj)\n    };\n  },\n  fromJSONValue: function (obj) {\n    return Base64.decode(obj.$binary);\n  }\n}, {\n  // Escaping one level\n  matchJSONValue: function (obj) {\n    return hasOwn(obj, '$escape') && Object.keys(obj).length === 1;\n  },\n  matchObject: function (obj) {\n    var match = false;\n\n    if (obj) {\n      var keyCount = Object.keys(obj).length;\n\n      if (keyCount === 1 || keyCount === 2) {\n        match = builtinConverters.some(function (converter) {\n          return converter.matchJSONValue(obj);\n        });\n      }\n    }\n\n    return match;\n  },\n  toJSONValue: function (obj) {\n    var newObj = {};\n    Object.keys(obj).forEach(function (key) {\n      newObj[key] = EJSON.toJSONValue(obj[key]);\n    });\n    return {\n      $escape: newObj\n    };\n  },\n  fromJSONValue: function (obj) {\n    var newObj = {};\n    Object.keys(obj.$escape).forEach(function (key) {\n      newObj[key] = EJSON.fromJSONValue(obj.$escape[key]);\n    });\n    return newObj;\n  }\n}, {\n  // Custom\n  matchJSONValue: function (obj) {\n    return hasOwn(obj, '$type') && hasOwn(obj, '$value') && Object.keys(obj).length === 2;\n  },\n  matchObject: function (obj) {\n    return EJSON._isCustomType(obj);\n  },\n  toJSONValue: function (obj) {\n    var jsonValue = Meteor._noYieldsAllowed(function () {\n      return obj.toJSONValue();\n    });\n\n    return {\n      $type: obj.typeName(),\n      $value: jsonValue\n    };\n  },\n  fromJSONValue: function (obj) {\n    var typeName = obj.$type;\n\n    if (!hasOwn(customTypes, typeName)) {\n      throw new Error(\"Custom EJSON type \" + typeName + \" is not defined\");\n    }\n\n    var converter = customTypes[typeName];\n    return Meteor._noYieldsAllowed(function () {\n      return converter(obj.$value);\n    });\n  }\n}];\n\nEJSON._isCustomType = function (obj) {\n  return obj && typeof obj.toJSONValue === 'function' && typeof obj.typeName === 'function' && hasOwn(customTypes, obj.typeName());\n};\n\nEJSON._getTypes = function () {\n  return customTypes;\n};\n\nEJSON._getConverters = function () {\n  return builtinConverters;\n}; // Either return the JSON-compatible version of the argument, or undefined (if\n// the item isn't itself replaceable, but maybe some fields in it are)\n\n\nvar toJSONValueHelper = function (item) {\n  for (var i = 0; i < builtinConverters.length; i++) {\n    var converter = builtinConverters[i];\n\n    if (converter.matchObject(item)) {\n      return converter.toJSONValue(item);\n    }\n  }\n\n  return undefined;\n}; // for both arrays and objects, in-place modification.\n\n\nvar adjustTypesToJSONValue = function (obj) {\n  // Is it an atom that we need to adjust?\n  if (obj === null) {\n    return null;\n  }\n\n  var maybeChanged = toJSONValueHelper(obj);\n\n  if (maybeChanged !== undefined) {\n    return maybeChanged;\n  } // Other atoms are unchanged.\n\n\n  if (_typeof(obj) !== 'object') {\n    return obj;\n  } // Iterate over array or object structure.\n\n\n  Object.keys(obj).forEach(function (key) {\n    var value = obj[key];\n\n    if (_typeof(value) !== 'object' && value !== undefined && !isInfOrNan(value)) {\n      return; // continue\n    }\n\n    var changed = toJSONValueHelper(value);\n\n    if (changed) {\n      obj[key] = changed;\n      return; // on to the next key\n    } // if we get here, value is an object but not adjustable\n    // at this level.  recurse.\n\n\n    adjustTypesToJSONValue(value);\n  });\n  return obj;\n};\n\nEJSON._adjustTypesToJSONValue = adjustTypesToJSONValue;\n/**\n * @summary Serialize an EJSON-compatible value into its plain JSON\n *          representation.\n * @locus Anywhere\n * @param {EJSON} val A value to serialize to plain JSON.\n */\n\nEJSON.toJSONValue = function (item) {\n  var changed = toJSONValueHelper(item);\n\n  if (changed !== undefined) {\n    return changed;\n  }\n\n  var newItem = item;\n\n  if (_typeof(item) === 'object') {\n    newItem = EJSON.clone(item);\n    adjustTypesToJSONValue(newItem);\n  }\n\n  return newItem;\n}; // Either return the argument changed to have the non-json\n// rep of itself (the Object version) or the argument itself.\n// DOES NOT RECURSE.  For actually getting the fully-changed value, use\n// EJSON.fromJSONValue\n\n\nvar fromJSONValueHelper = function (value) {\n  if (_typeof(value) === 'object' && value !== null) {\n    var keys = Object.keys(value);\n\n    if (keys.length <= 2 && keys.every(function (k) {\n      return typeof k === 'string' && k.substr(0, 1) === '$';\n    })) {\n      for (var i = 0; i < builtinConverters.length; i++) {\n        var converter = builtinConverters[i];\n\n        if (converter.matchJSONValue(value)) {\n          return converter.fromJSONValue(value);\n        }\n      }\n    }\n  }\n\n  return value;\n}; // for both arrays and objects. Tries its best to just\n// use the object you hand it, but may return something\n// different if the object you hand it itself needs changing.\n\n\nvar adjustTypesFromJSONValue = function (obj) {\n  if (obj === null) {\n    return null;\n  }\n\n  var maybeChanged = fromJSONValueHelper(obj);\n\n  if (maybeChanged !== obj) {\n    return maybeChanged;\n  } // Other atoms are unchanged.\n\n\n  if (_typeof(obj) !== 'object') {\n    return obj;\n  }\n\n  Object.keys(obj).forEach(function (key) {\n    var value = obj[key];\n\n    if (_typeof(value) === 'object') {\n      var changed = fromJSONValueHelper(value);\n\n      if (value !== changed) {\n        obj[key] = changed;\n        return;\n      } // if we get here, value is an object but not adjustable\n      // at this level.  recurse.\n\n\n      adjustTypesFromJSONValue(value);\n    }\n  });\n  return obj;\n};\n\nEJSON._adjustTypesFromJSONValue = adjustTypesFromJSONValue;\n/**\n * @summary Deserialize an EJSON value from its plain JSON representation.\n * @locus Anywhere\n * @param {JSONCompatible} val A value to deserialize into EJSON.\n */\n\nEJSON.fromJSONValue = function (item) {\n  var changed = fromJSONValueHelper(item);\n\n  if (changed === item && _typeof(item) === 'object') {\n    changed = EJSON.clone(item);\n    adjustTypesFromJSONValue(changed);\n  }\n\n  return changed;\n};\n/**\n * @summary Serialize a value to a string. For EJSON values, the serialization\n *          fully represents the value. For non-EJSON values, serializes the\n *          same way as `JSON.stringify`.\n * @locus Anywhere\n * @param {EJSON} val A value to stringify.\n * @param {Object} [options]\n * @param {Boolean | Integer | String} options.indent Indents objects and\n * arrays for easy readability.  When `true`, indents by 2 spaces; when an\n * integer, indents by that number of spaces; and when a string, uses the\n * string as the indentation pattern.\n * @param {Boolean} options.canonical When `true`, stringifies keys in an\n *                                    object in sorted order.\n */\n\n\nEJSON.stringify = function (item, options) {\n  var serialized;\n  var json = EJSON.toJSONValue(item);\n\n  if (options && (options.canonical || options.indent)) {\n    var canonicalStringify;\n    module.link(\"./stringify\", {\n      \"default\": function (v) {\n        canonicalStringify = v;\n      }\n    }, 0);\n    serialized = canonicalStringify(json, options);\n  } else {\n    serialized = JSON.stringify(json);\n  }\n\n  return serialized;\n};\n/**\n * @summary Parse a string into an EJSON value. Throws an error if the string\n *          is not valid EJSON.\n * @locus Anywhere\n * @param {String} str A string to parse into an EJSON value.\n */\n\n\nEJSON.parse = function (item) {\n  if (typeof item !== 'string') {\n    throw new Error('EJSON.parse argument should be a string');\n  }\n\n  return EJSON.fromJSONValue(JSON.parse(item));\n};\n/**\n * @summary Returns true if `x` is a buffer of binary data, as returned from\n *          [`EJSON.newBinary`](#ejson_new_binary).\n * @param {Object} x The variable to check.\n * @locus Anywhere\n */\n\n\nEJSON.isBinary = function (obj) {\n  return !!(typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array || obj && obj.$Uint8ArrayPolyfill);\n};\n/**\n * @summary Return true if `a` and `b` are equal to each other.  Return false\n *          otherwise.  Uses the `equals` method on `a` if present, otherwise\n *          performs a deep comparison.\n * @locus Anywhere\n * @param {EJSON} a\n * @param {EJSON} b\n * @param {Object} [options]\n * @param {Boolean} options.keyOrderSensitive Compare in key sensitive order,\n * if supported by the JavaScript implementation.  For example, `{a: 1, b: 2}`\n * is equal to `{b: 2, a: 1}` only when `keyOrderSensitive` is `false`.  The\n * default is `false`.\n */\n\n\nEJSON.equals = function (a, b, options) {\n  var i;\n  var keyOrderSensitive = !!(options && options.keyOrderSensitive);\n\n  if (a === b) {\n    return true;\n  } // This differs from the IEEE spec for NaN equality, b/c we don't want\n  // anything ever with a NaN to be poisoned from becoming equal to anything.\n\n\n  if (Number.isNaN(a) && Number.isNaN(b)) {\n    return true;\n  } // if either one is falsy, they'd have to be === to be equal\n\n\n  if (!a || !b) {\n    return false;\n  }\n\n  if (!(_typeof(a) === 'object' && _typeof(b) === 'object')) {\n    return false;\n  }\n\n  if (a instanceof Date && b instanceof Date) {\n    return a.valueOf() === b.valueOf();\n  }\n\n  if (EJSON.isBinary(a) && EJSON.isBinary(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (typeof a.equals === 'function') {\n    return a.equals(b, options);\n  }\n\n  if (typeof b.equals === 'function') {\n    return b.equals(a, options);\n  }\n\n  if (a instanceof Array) {\n    if (!(b instanceof Array)) {\n      return false;\n    }\n\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (i = 0; i < a.length; i++) {\n      if (!EJSON.equals(a[i], b[i], options)) {\n        return false;\n      }\n    }\n\n    return true;\n  } // fallback for custom types that don't implement their own equals\n\n\n  switch (EJSON._isCustomType(a) + EJSON._isCustomType(b)) {\n    case 1:\n      return false;\n\n    case 2:\n      return EJSON.equals(EJSON.toJSONValue(a), EJSON.toJSONValue(b));\n\n    default: // Do nothing\n\n  } // fall back to structural equality of objects\n\n\n  var ret;\n  var aKeys = Object.keys(a);\n  var bKeys = Object.keys(b);\n\n  if (keyOrderSensitive) {\n    i = 0;\n    ret = aKeys.every(function (key) {\n      if (i >= bKeys.length) {\n        return false;\n      }\n\n      if (key !== bKeys[i]) {\n        return false;\n      }\n\n      if (!EJSON.equals(a[key], b[bKeys[i]], options)) {\n        return false;\n      }\n\n      i++;\n      return true;\n    });\n  } else {\n    i = 0;\n    ret = aKeys.every(function (key) {\n      if (!hasOwn(b, key)) {\n        return false;\n      }\n\n      if (!EJSON.equals(a[key], b[key], options)) {\n        return false;\n      }\n\n      i++;\n      return true;\n    });\n  }\n\n  return ret && i === bKeys.length;\n};\n/**\n * @summary Return a deep copy of `val`.\n * @locus Anywhere\n * @param {EJSON} val A value to copy.\n */\n\n\nEJSON.clone = function (v) {\n  var ret;\n\n  if (_typeof(v) !== 'object') {\n    return v;\n  }\n\n  if (v === null) {\n    return null; // null has typeof \"object\"\n  }\n\n  if (v instanceof Date) {\n    return new Date(v.getTime());\n  } // RegExps are not really EJSON elements (eg we don't define a serialization\n  // for them), but they're immutable anyway, so we can support them in clone.\n\n\n  if (v instanceof RegExp) {\n    return v;\n  }\n\n  if (EJSON.isBinary(v)) {\n    ret = EJSON.newBinary(v.length);\n\n    for (var i = 0; i < v.length; i++) {\n      ret[i] = v[i];\n    }\n\n    return ret;\n  }\n\n  if (Array.isArray(v)) {\n    return v.map(function (value) {\n      return EJSON.clone(value);\n    });\n  }\n\n  if (isArguments(v)) {\n    return Array.from(v).map(function (value) {\n      return EJSON.clone(value);\n    });\n  } // handle general user-defined typed Objects if they have a clone method\n\n\n  if (typeof v.clone === 'function') {\n    return v.clone();\n  } // handle other custom types\n\n\n  if (EJSON._isCustomType(v)) {\n    return EJSON.fromJSONValue(EJSON.clone(EJSON.toJSONValue(v)), true);\n  } // handle other objects\n\n\n  ret = {};\n  Object.keys(v).forEach(function (key) {\n    ret[key] = EJSON.clone(v[key]);\n  });\n  return ret;\n};\n/**\n * @summary Allocate a new buffer of binary data that EJSON can serialize.\n * @locus Anywhere\n * @param {Number} size The number of bytes of binary data to allocate.\n */\n// EJSON.newBinary is the public documented API for this functionality,\n// but the implementation is in the 'base64' package to avoid\n// introducing a circular dependency. (If the implementation were here,\n// then 'base64' would have to use EJSON.newBinary, and 'ejson' would\n// also have to use 'base64'.)\n\n\nEJSON.newBinary = Base64.newBinary;","map":{"version":3,"sources":["packages/ejson/ejson.js"],"names":["_typeof","module","link","default","v","export","EJSON","customTypes","hasOwn","obj","prop","hasOwnProperty","call","isArguments","isInfOrNan","Number","isNaN","Infinity","addType","name","factory","Error","builtinConverters","matchJSONValue","Object","keys","length","matchObject","Date","toJSONValue","$date","getTime","fromJSONValue","RegExp","regexp","$regexp","source","$flags","flags","slice","replace","sign","$InfNaN","Uint8Array","$binary","Base64","encode","decode","match","keyCount","some","converter","newObj","forEach","key","$escape","_isCustomType","jsonValue","Meteor","_noYieldsAllowed","$type","typeName","$value","_getTypes","_getConverters","toJSONValueHelper","item","i","undefined","adjustTypesToJSONValue","maybeChanged","value","changed","_adjustTypesToJSONValue","newItem","clone","fromJSONValueHelper","every","k","substr","adjustTypesFromJSONValue","_adjustTypesFromJSONValue","stringify","options","serialized","json","canonical","indent","canonicalStringify","JSON","parse","isBinary","$Uint8ArrayPolyfill","equals","a","b","keyOrderSensitive","valueOf","Array","ret","aKeys","bKeys","newBinary","isArray","map","from"],"mappings":"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","sourcesContent":["/**\n * @namespace\n * @summary Namespace for EJSON functions\n */\nconst EJSON = {};\n\n// Custom type interface definition\n/**\n * @class CustomType\n * @instanceName customType\n * @memberOf EJSON\n * @summary The interface that a class must satisfy to be able to become an\n * EJSON custom type via EJSON.addType.\n */\n\n/**\n * @function typeName\n * @memberOf EJSON.CustomType\n * @summary Return the tag used to identify this type.  This must match the\n *          tag used to register this type with\n *          [`EJSON.addType`](#ejson_add_type).\n * @locus Anywhere\n * @instance\n */\n\n/**\n * @function toJSONValue\n * @memberOf EJSON.CustomType\n * @summary Serialize this instance into a JSON-compatible value.\n * @locus Anywhere\n * @instance\n */\n\n/**\n * @function clone\n * @memberOf EJSON.CustomType\n * @summary Return a value `r` such that `this.equals(r)` is true, and\n *          modifications to `r` do not affect `this` and vice versa.\n * @locus Anywhere\n * @instance\n */\n\n/**\n * @function equals\n * @memberOf EJSON.CustomType\n * @summary Return `true` if `other` has a value equal to `this`; `false`\n *          otherwise.\n * @locus Anywhere\n * @param {Object} other Another object to compare this to.\n * @instance\n */\n\nconst customTypes = {};\n\nconst hasOwn = (obj, prop) => ({}).hasOwnProperty.call(obj, prop);\n\nconst isArguments = obj => obj != null && hasOwn(obj, 'callee');\n\nconst isInfOrNan =\n  obj => Number.isNaN(obj) || obj === Infinity || obj === -Infinity;\n\n// Add a custom type, using a method of your choice to get to and\n// from a basic JSON-able representation.  The factory argument\n// is a function of JSON-able --> your object\n// The type you add must have:\n// - A toJSONValue() method, so that Meteor can serialize it\n// - a typeName() method, to show how to look it up in our type table.\n// It is okay if these methods are monkey-patched on.\n// EJSON.clone will use toJSONValue and the given factory to produce\n// a clone, but you may specify a method clone() that will be\n// used instead.\n// Similarly, EJSON.equals will use toJSONValue to make comparisons,\n// but you may provide a method equals() instead.\n/**\n * @summary Add a custom datatype to EJSON.\n * @locus Anywhere\n * @param {String} name A tag for your custom type; must be unique among\n *                      custom data types defined in your project, and must\n *                      match the result of your type's `typeName` method.\n * @param {Function} factory A function that deserializes a JSON-compatible\n *                           value into an instance of your type.  This should\n *                           match the serialization performed by your\n *                           type's `toJSONValue` method.\n */\nEJSON.addType = (name, factory) => {\n  if (hasOwn(customTypes, name)) {\n    throw new Error(`Type ${name} already present`);\n  }\n  customTypes[name] = factory;\n};\n\nconst builtinConverters = [\n  { // Date\n    matchJSONValue(obj) {\n      return hasOwn(obj, '$date') && Object.keys(obj).length === 1;\n    },\n    matchObject(obj) {\n      return obj instanceof Date;\n    },\n    toJSONValue(obj) {\n      return {$date: obj.getTime()};\n    },\n    fromJSONValue(obj) {\n      return new Date(obj.$date);\n    },\n  },\n  { // RegExp\n    matchJSONValue(obj) {\n      return hasOwn(obj, '$regexp')\n        && hasOwn(obj, '$flags')\n        && Object.keys(obj).length === 2;\n    },\n    matchObject(obj) {\n      return obj instanceof RegExp;\n    },\n    toJSONValue(regexp) {\n      return {\n        $regexp: regexp.source,\n        $flags: regexp.flags\n      };\n    },\n    fromJSONValue(obj) {\n      // Replaces duplicate / invalid flags.\n      return new RegExp(\n        obj.$regexp,\n        obj.$flags\n          // Cut off flags at 50 chars to avoid abusing RegExp for DOS.\n          .slice(0, 50)\n          .replace(/[^gimuy]/g,'')\n          .replace(/(.)(?=.*\\1)/g, '')\n      );\n    },\n  },\n  { // NaN, Inf, -Inf. (These are the only objects with typeof !== 'object'\n    // which we match.)\n    matchJSONValue(obj) {\n      return hasOwn(obj, '$InfNaN') && Object.keys(obj).length === 1;\n    },\n    matchObject: isInfOrNan,\n    toJSONValue(obj) {\n      let sign;\n      if (Number.isNaN(obj)) {\n        sign = 0;\n      } else if (obj === Infinity) {\n        sign = 1;\n      } else {\n        sign = -1;\n      }\n      return {$InfNaN: sign};\n    },\n    fromJSONValue(obj) {\n      return obj.$InfNaN / 0;\n    },\n  },\n  { // Binary\n    matchJSONValue(obj) {\n      return hasOwn(obj, '$binary') && Object.keys(obj).length === 1;\n    },\n    matchObject(obj) {\n      return typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array\n        || (obj && hasOwn(obj, '$Uint8ArrayPolyfill'));\n    },\n    toJSONValue(obj) {\n      return {$binary: Base64.encode(obj)};\n    },\n    fromJSONValue(obj) {\n      return Base64.decode(obj.$binary);\n    },\n  },\n  { // Escaping one level\n    matchJSONValue(obj) {\n      return hasOwn(obj, '$escape') && Object.keys(obj).length === 1;\n    },\n    matchObject(obj) {\n      let match = false;\n      if (obj) {\n        const keyCount = Object.keys(obj).length;\n        if (keyCount === 1 || keyCount === 2) {\n          match =\n            builtinConverters.some(converter => converter.matchJSONValue(obj));\n        }\n      }\n      return match;\n    },\n    toJSONValue(obj) {\n      const newObj = {};\n      Object.keys(obj).forEach(key => {\n        newObj[key] = EJSON.toJSONValue(obj[key]);\n      });\n      return {$escape: newObj};\n    },\n    fromJSONValue(obj) {\n      const newObj = {};\n      Object.keys(obj.$escape).forEach(key => {\n        newObj[key] = EJSON.fromJSONValue(obj.$escape[key]);\n      });\n      return newObj;\n    },\n  },\n  { // Custom\n    matchJSONValue(obj) {\n      return hasOwn(obj, '$type')\n        && hasOwn(obj, '$value') && Object.keys(obj).length === 2;\n    },\n    matchObject(obj) {\n      return EJSON._isCustomType(obj);\n    },\n    toJSONValue(obj) {\n      const jsonValue = Meteor._noYieldsAllowed(() => obj.toJSONValue());\n      return {$type: obj.typeName(), $value: jsonValue};\n    },\n    fromJSONValue(obj) {\n      const typeName = obj.$type;\n      if (!hasOwn(customTypes, typeName)) {\n        throw new Error(`Custom EJSON type ${typeName} is not defined`);\n      }\n      const converter = customTypes[typeName];\n      return Meteor._noYieldsAllowed(() => converter(obj.$value));\n    },\n  },\n];\n\nEJSON._isCustomType = (obj) => (\n  obj &&\n  typeof obj.toJSONValue === 'function' &&\n  typeof obj.typeName === 'function' &&\n  hasOwn(customTypes, obj.typeName())\n);\n\nEJSON._getTypes = () => customTypes;\n\nEJSON._getConverters = () => builtinConverters;\n\n// Either return the JSON-compatible version of the argument, or undefined (if\n// the item isn't itself replaceable, but maybe some fields in it are)\nconst toJSONValueHelper = item => {\n  for (let i = 0; i < builtinConverters.length; i++) {\n    const converter = builtinConverters[i];\n    if (converter.matchObject(item)) {\n      return converter.toJSONValue(item);\n    }\n  }\n  return undefined;\n};\n\n// for both arrays and objects, in-place modification.\nconst adjustTypesToJSONValue = obj => {\n  // Is it an atom that we need to adjust?\n  if (obj === null) {\n    return null;\n  }\n\n  const maybeChanged = toJSONValueHelper(obj);\n  if (maybeChanged !== undefined) {\n    return maybeChanged;\n  }\n\n  // Other atoms are unchanged.\n  if (typeof obj !== 'object') {\n    return obj;\n  }\n\n  // Iterate over array or object structure.\n  Object.keys(obj).forEach(key => {\n    const value = obj[key];\n    if (typeof value !== 'object' && value !== undefined &&\n        !isInfOrNan(value)) {\n      return; // continue\n    }\n\n    const changed = toJSONValueHelper(value);\n    if (changed) {\n      obj[key] = changed;\n      return; // on to the next key\n    }\n    // if we get here, value is an object but not adjustable\n    // at this level.  recurse.\n    adjustTypesToJSONValue(value);\n  });\n  return obj;\n};\n\nEJSON._adjustTypesToJSONValue = adjustTypesToJSONValue;\n\n/**\n * @summary Serialize an EJSON-compatible value into its plain JSON\n *          representation.\n * @locus Anywhere\n * @param {EJSON} val A value to serialize to plain JSON.\n */\nEJSON.toJSONValue = item => {\n  const changed = toJSONValueHelper(item);\n  if (changed !== undefined) {\n    return changed;\n  }\n\n  let newItem = item;\n  if (typeof item === 'object') {\n    newItem = EJSON.clone(item);\n    adjustTypesToJSONValue(newItem);\n  }\n  return newItem;\n};\n\n// Either return the argument changed to have the non-json\n// rep of itself (the Object version) or the argument itself.\n// DOES NOT RECURSE.  For actually getting the fully-changed value, use\n// EJSON.fromJSONValue\nconst fromJSONValueHelper = value => {\n  if (typeof value === 'object' && value !== null) {\n    const keys = Object.keys(value);\n    if (keys.length <= 2\n        && keys.every(k => typeof k === 'string' && k.substr(0, 1) === '$')) {\n      for (let i = 0; i < builtinConverters.length; i++) {\n        const converter = builtinConverters[i];\n        if (converter.matchJSONValue(value)) {\n          return converter.fromJSONValue(value);\n        }\n      }\n    }\n  }\n  return value;\n};\n\n// for both arrays and objects. Tries its best to just\n// use the object you hand it, but may return something\n// different if the object you hand it itself needs changing.\nconst adjustTypesFromJSONValue = obj => {\n  if (obj === null) {\n    return null;\n  }\n\n  const maybeChanged = fromJSONValueHelper(obj);\n  if (maybeChanged !== obj) {\n    return maybeChanged;\n  }\n\n  // Other atoms are unchanged.\n  if (typeof obj !== 'object') {\n    return obj;\n  }\n\n  Object.keys(obj).forEach(key => {\n    const value = obj[key];\n    if (typeof value === 'object') {\n      const changed = fromJSONValueHelper(value);\n      if (value !== changed) {\n        obj[key] = changed;\n        return;\n      }\n      // if we get here, value is an object but not adjustable\n      // at this level.  recurse.\n      adjustTypesFromJSONValue(value);\n    }\n  });\n  return obj;\n};\n\nEJSON._adjustTypesFromJSONValue = adjustTypesFromJSONValue;\n\n/**\n * @summary Deserialize an EJSON value from its plain JSON representation.\n * @locus Anywhere\n * @param {JSONCompatible} val A value to deserialize into EJSON.\n */\nEJSON.fromJSONValue = item => {\n  let changed = fromJSONValueHelper(item);\n  if (changed === item && typeof item === 'object') {\n    changed = EJSON.clone(item);\n    adjustTypesFromJSONValue(changed);\n  }\n  return changed;\n};\n\n/**\n * @summary Serialize a value to a string. For EJSON values, the serialization\n *          fully represents the value. For non-EJSON values, serializes the\n *          same way as `JSON.stringify`.\n * @locus Anywhere\n * @param {EJSON} val A value to stringify.\n * @param {Object} [options]\n * @param {Boolean | Integer | String} options.indent Indents objects and\n * arrays for easy readability.  When `true`, indents by 2 spaces; when an\n * integer, indents by that number of spaces; and when a string, uses the\n * string as the indentation pattern.\n * @param {Boolean} options.canonical When `true`, stringifies keys in an\n *                                    object in sorted order.\n */\nEJSON.stringify = (item, options) => {\n  let serialized;\n  const json = EJSON.toJSONValue(item);\n  if (options && (options.canonical || options.indent)) {\n    import canonicalStringify from './stringify';\n    serialized = canonicalStringify(json, options);\n  } else {\n    serialized = JSON.stringify(json);\n  }\n  return serialized;\n};\n\n/**\n * @summary Parse a string into an EJSON value. Throws an error if the string\n *          is not valid EJSON.\n * @locus Anywhere\n * @param {String} str A string to parse into an EJSON value.\n */\nEJSON.parse = item => {\n  if (typeof item !== 'string') {\n    throw new Error('EJSON.parse argument should be a string');\n  }\n  return EJSON.fromJSONValue(JSON.parse(item));\n};\n\n/**\n * @summary Returns true if `x` is a buffer of binary data, as returned from\n *          [`EJSON.newBinary`](#ejson_new_binary).\n * @param {Object} x The variable to check.\n * @locus Anywhere\n */\nEJSON.isBinary = obj => {\n  return !!((typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array) ||\n    (obj && obj.$Uint8ArrayPolyfill));\n};\n\n/**\n * @summary Return true if `a` and `b` are equal to each other.  Return false\n *          otherwise.  Uses the `equals` method on `a` if present, otherwise\n *          performs a deep comparison.\n * @locus Anywhere\n * @param {EJSON} a\n * @param {EJSON} b\n * @param {Object} [options]\n * @param {Boolean} options.keyOrderSensitive Compare in key sensitive order,\n * if supported by the JavaScript implementation.  For example, `{a: 1, b: 2}`\n * is equal to `{b: 2, a: 1}` only when `keyOrderSensitive` is `false`.  The\n * default is `false`.\n */\nEJSON.equals = (a, b, options) => {\n  let i;\n  const keyOrderSensitive = !!(options && options.keyOrderSensitive);\n  if (a === b) {\n    return true;\n  }\n\n  // This differs from the IEEE spec for NaN equality, b/c we don't want\n  // anything ever with a NaN to be poisoned from becoming equal to anything.\n  if (Number.isNaN(a) && Number.isNaN(b)) {\n    return true;\n  }\n\n  // if either one is falsy, they'd have to be === to be equal\n  if (!a || !b) {\n    return false;\n  }\n\n  if (!(typeof a === 'object' && typeof b === 'object')) {\n    return false;\n  }\n\n  if (a instanceof Date && b instanceof Date) {\n    return a.valueOf() === b.valueOf();\n  }\n\n  if (EJSON.isBinary(a) && EJSON.isBinary(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  if (typeof (a.equals) === 'function') {\n    return a.equals(b, options);\n  }\n\n  if (typeof (b.equals) === 'function') {\n    return b.equals(a, options);\n  }\n\n  if (a instanceof Array) {\n    if (!(b instanceof Array)) {\n      return false;\n    }\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (i = 0; i < a.length; i++) {\n      if (!EJSON.equals(a[i], b[i], options)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // fallback for custom types that don't implement their own equals\n  switch (EJSON._isCustomType(a) + EJSON._isCustomType(b)) {\n    case 1: return false;\n    case 2: return EJSON.equals(EJSON.toJSONValue(a), EJSON.toJSONValue(b));\n    default: // Do nothing\n  }\n\n  // fall back to structural equality of objects\n  let ret;\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n  if (keyOrderSensitive) {\n    i = 0;\n    ret = aKeys.every(key => {\n      if (i >= bKeys.length) {\n        return false;\n      }\n      if (key !== bKeys[i]) {\n        return false;\n      }\n      if (!EJSON.equals(a[key], b[bKeys[i]], options)) {\n        return false;\n      }\n      i++;\n      return true;\n    });\n  } else {\n    i = 0;\n    ret = aKeys.every(key => {\n      if (!hasOwn(b, key)) {\n        return false;\n      }\n      if (!EJSON.equals(a[key], b[key], options)) {\n        return false;\n      }\n      i++;\n      return true;\n    });\n  }\n  return ret && i === bKeys.length;\n};\n\n/**\n * @summary Return a deep copy of `val`.\n * @locus Anywhere\n * @param {EJSON} val A value to copy.\n */\nEJSON.clone = v => {\n  let ret;\n  if (typeof v !== 'object') {\n    return v;\n  }\n\n  if (v === null) {\n    return null; // null has typeof \"object\"\n  }\n\n  if (v instanceof Date) {\n    return new Date(v.getTime());\n  }\n\n  // RegExps are not really EJSON elements (eg we don't define a serialization\n  // for them), but they're immutable anyway, so we can support them in clone.\n  if (v instanceof RegExp) {\n    return v;\n  }\n\n  if (EJSON.isBinary(v)) {\n    ret = EJSON.newBinary(v.length);\n    for (let i = 0; i < v.length; i++) {\n      ret[i] = v[i];\n    }\n    return ret;\n  }\n\n  if (Array.isArray(v)) {\n    return v.map(value => EJSON.clone(value));\n  }\n\n  if (isArguments(v)) {\n    return Array.from(v).map(value => EJSON.clone(value));\n  }\n\n  // handle general user-defined typed Objects if they have a clone method\n  if (typeof v.clone === 'function') {\n    return v.clone();\n  }\n\n  // handle other custom types\n  if (EJSON._isCustomType(v)) {\n    return EJSON.fromJSONValue(EJSON.clone(EJSON.toJSONValue(v)), true);\n  }\n\n  // handle other objects\n  ret = {};\n  Object.keys(v).forEach((key) => {\n    ret[key] = EJSON.clone(v[key]);\n  });\n  return ret;\n};\n\n/**\n * @summary Allocate a new buffer of binary data that EJSON can serialize.\n * @locus Anywhere\n * @param {Number} size The number of bytes of binary data to allocate.\n */\n// EJSON.newBinary is the public documented API for this functionality,\n// but the implementation is in the 'base64' package to avoid\n// introducing a circular dependency. (If the implementation were here,\n// then 'base64' would have to use EJSON.newBinary, and 'ejson' would\n// also have to use 'base64'.)\nEJSON.newBinary = Base64.newBinary;\n\nexport { EJSON };\n"]},"sourceType":"module","hash":"6ac2ad296bb61df004276e692a8e27f93506636a"}
